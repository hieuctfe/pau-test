{"remainingRequest":"/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/babel-loader/lib/index.js!/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/src/components/v-carousel/Carousel.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/src/components/v-carousel/Carousel.vue","mtime":1552898513897},{"path":"/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.math.sign\";\nimport \"core-js/modules/es6.regexp.match\";\nimport _toConsumableArray from \"/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport \"core-js/modules/es6.array.sort\";\nimport _typeof from \"/Volumes/Document/Fireapps/DSSellerFE/ds-seller-frontend/node_modules/@babel/runtime-corejs2/helpers/esm/typeof\";\nimport \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport autoplay from \"./mixins/autoplay\";\nimport debounce from \"./utils/debounce\";\nimport Navigation from \"./Navigation.vue\";\nimport Pagination from \"./Pagination.vue\";\nimport Slide from \"./Slide.vue\";\nvar transitionStartNames = {\n  onwebkittransitionstart: \"webkitTransitionStart\",\n  onmoztransitionstart: \"transitionstart\",\n  onotransitionstart: \"oTransitionStart otransitionstart\",\n  ontransitionstart: \"transitionstart\"\n};\nvar transitionEndNames = {\n  onwebkittransitionend: \"webkitTransitionEnd\",\n  onmoztransitionend: \"transitionend\",\n  onotransitionend: \"oTransitionEnd otransitionend\",\n  ontransitionend: \"transitionend\"\n};\n\nvar getTransitionStart = function getTransitionStart() {\n  for (var name in transitionStartNames) {\n    if (name in window) {\n      return transitionStartNames[name];\n    }\n  }\n};\n\nvar getTransitionEnd = function getTransitionEnd() {\n  for (var name in transitionEndNames) {\n    if (name in window) {\n      return transitionEndNames[name];\n    }\n  }\n};\n\nexport default {\n  name: \"carousel\",\n  beforeUpdate: function beforeUpdate() {\n    this.computeCarouselWidth();\n  },\n  components: {\n    Navigation: Navigation,\n    Pagination: Pagination,\n    Slide: Slide\n  },\n  data: function data() {\n    return {\n      browserWidth: null,\n      carouselWidth: 0,\n      currentPage: 0,\n      dragging: false,\n      dragMomentum: 0,\n      dragOffset: 0,\n      dragStartY: 0,\n      dragStartX: 0,\n      isTouch: typeof window !== \"undefined\" && \"ontouchstart\" in window,\n      offset: 0,\n      refreshRate: 16,\n      slideCount: 0,\n      transitionstart: \"transitionstart\",\n      transitionend: \"transitionend\",\n      currentHeight: \"auto\"\n    };\n  },\n  mixins: [autoplay],\n  // use `provide` to avoid `Slide` being nested with other components\n  provide: function provide() {\n    return {\n      carousel: this\n    };\n  },\n  props: {\n    /**\n     *  Adjust the height of the carousel for the current slide\n     */\n    adjustableHeight: {\n      type: Boolean,\n      default: false\n    },\n\n    /**\n     * Slide transition easing for adjustableHeight\n     * Any valid CSS transition easing accepted\n     */\n    adjustableHeightEasing: {\n      type: String\n    },\n\n    /**\n     *  Center images when the size is less than the container width\n     */\n    centerMode: {\n      type: Boolean,\n      default: false\n    },\n\n    /**\n     * Slide transition easing\n     * Any valid CSS transition easing accepted\n     */\n    easing: {\n      type: String,\n      default: \"ease\"\n    },\n\n    /**\n     * Flag to make the carousel loop around when it reaches the end\n     */\n    loop: {\n      type: Boolean,\n      default: false\n    },\n\n    /**\n     * Minimum distance for the swipe to trigger\n     * a slide advance\n     */\n    minSwipeDistance: {\n      type: Number,\n      default: 8\n    },\n\n    /**\n     * Flag to toggle mouse dragging\n     */\n    mouseDrag: {\n      type: Boolean,\n      default: true\n    },\n\n    /**\n     * Flag to toggle touch dragging\n     */\n    touchDrag: {\n      type: Boolean,\n      default: true\n    },\n\n    /**\n     * Listen for an external navigation request using this prop.\n     */\n    navigateTo: {\n      type: [Number, Array],\n      default: 0\n    },\n\n    /**\n     * Amount of padding to apply around the label in pixels\n     */\n    navigationClickTargetSize: {\n      type: Number,\n      default: 8\n    },\n\n    /**\n     * Flag to render the navigation component\n     * (next/prev buttons)\n     */\n    navigationEnabled: {\n      type: Boolean,\n      default: false\n    },\n\n    /**\n     * Text content of the navigation next button\n     */\n    navigationNextLabel: {\n      type: String,\n      default: \"&#9654\"\n    },\n\n    /**\n     * Text content of the navigation prev button\n     */\n    navigationPrevLabel: {\n      type: String,\n      default: \"&#9664\"\n    },\n\n    /**\n     * The fill color of the active pagination dot\n     * Any valid CSS color is accepted\n     */\n    paginationActiveColor: {\n      type: String,\n      default: \"#000000\"\n    },\n\n    /**\n     * The fill color of pagination dots\n     * Any valid CSS color is accepted\n     */\n    paginationColor: {\n      type: String,\n      default: \"#efefef\"\n    },\n\n    /**\n     * Flag to render pagination component\n     */\n    paginationEnabled: {\n      type: Boolean,\n      default: true\n    },\n\n    /**\n     * The padding inside each pagination dot\n     * Pixel values are accepted\n     */\n    paginationPadding: {\n      type: Number,\n      default: 10\n    },\n\n    /**\n     * Configure the position for the pagination component.\n     * The possible values are: 'bottom', 'top', 'bottom-overlay' and 'top-overlay'\n     */\n    paginationPosition: {\n      type: String,\n      default: \"bottom\"\n    },\n\n    /**\n     * The size of each pagination dot\n     * Pixel values are accepted\n     */\n    paginationSize: {\n      type: Number,\n      default: 10\n    },\n\n    /**\n     * Maximum number of slides displayed on each page\n     */\n    perPage: {\n      type: Number,\n      default: 2\n    },\n\n    /**\n     * Configure the number of visible slides with a particular browser width.\n     * This will be an array of arrays, ex. [[320, 2], [1199, 4]]\n     * Formatted as [x, y] where x=browser width, and y=number of slides displayed.\n     * ex. [1199, 4] means if (window <= 1199) then show 4 slides per page\n     */\n    perPageCustom: {\n      type: Array\n    },\n\n    /**\n     * Resistance coefficient to dragging on the edge of the carousel\n     * This dictates the effect of the pull as you move towards the boundaries\n     */\n    resistanceCoef: {\n      type: Number,\n      default: 20\n    },\n\n    /**\n     * Scroll per page, not per item\n     */\n    scrollPerPage: {\n      type: Boolean,\n      default: true\n    },\n\n    /**\n     *  Space padding option adds left and right padding style (in pixels) onto VueCarousel-inner.\n     */\n    spacePadding: {\n      type: Number,\n      default: 0\n    },\n\n    /**\n     *  Specify by how much should the space padding value be multiplied of, to re-arange the final slide padding.\n     */\n    spacePaddingMaxOffsetFactor: {\n      type: Number,\n      default: 0\n    },\n\n    /**\n     * Slide transition speed\n     * Number of milliseconds accepted\n     */\n    speed: {\n      type: Number,\n      default: 500\n    },\n\n    /**\n     * Name (tag) of slide component\n     * Overwrite when extending slide component\n     */\n    tagName: {\n      type: String,\n      default: \"slide\"\n    },\n\n    /**\n     * Support for v-model functionality\n     */\n    value: {\n      type: Number\n    }\n  },\n  watch: {\n    value: function value(val) {\n      if (val !== this.currentPage) {\n        this.goToPage(val);\n        this.render();\n      }\n    },\n    navigateTo: {\n      immediate: true,\n      handler: function handler(val) {\n        var _this = this;\n\n        // checking if val is an array, for arrays typeof returns object\n        if (_typeof(val) === \"object\") {\n          if (val[1] == false) {\n            // following code is to disable animation\n            this.dragging = true; // clear dragging after refresh rate\n\n            setTimeout(function () {\n              _this.dragging = false;\n            }, this.refreshRate);\n          }\n\n          this.$nextTick(function () {\n            _this.goToPage(val[0]);\n          });\n        } else {\n          this.$nextTick(function () {\n            _this.goToPage(val);\n          });\n        }\n      }\n    },\n    currentPage: function currentPage(val) {\n      this.$emit(\"pageChange\", val);\n      this.$emit(\"page-change\", val);\n      this.$emit(\"input\", val);\n    },\n    autoplay: function autoplay(val) {\n      if (val === false) {\n        this.pauseAutoplay();\n      } else {\n        this.restartAutoplay();\n      }\n    }\n  },\n  computed: {\n    /**\n     * Given a viewport width, find the number of slides to display\n     * @param  {Number} width Current viewport width in pixels\n     * @return {Number} Number of slides to display\n     */\n    breakpointSlidesPerPage: function breakpointSlidesPerPage() {\n      if (!this.perPageCustom) {\n        return this.perPage;\n      }\n\n      var breakpointArray = this.perPageCustom;\n      var width = this.browserWidth;\n      var breakpoints = breakpointArray.sort(function (a, b) {\n        return a[0] > b[0] ? -1 : 1;\n      }); // Reduce the breakpoints to entries where the width is in range\n      // The breakpoint arrays are formatted as [widthToMatch, numberOfSlides]\n\n      var matches = breakpoints.filter(function (breakpoint) {\n        return width >= breakpoint[0];\n      }); // If there is a match, the result should return only\n      // the slide count from the first matching breakpoint\n\n      var match = matches[0] && matches[0][1];\n      return match || this.perPage;\n    },\n\n    /**\n     * @return {Boolean} Can the slider move forward?\n     */\n    canAdvanceForward: function canAdvanceForward() {\n      return this.loop || this.offset < this.maxOffset;\n    },\n\n    /**\n     * @return {Boolean} Can the slider move backward?\n     */\n    canAdvanceBackward: function canAdvanceBackward() {\n      return this.loop || this.currentPage > 0;\n    },\n\n    /**\n     * Number of slides to display per page in the current context.\n     * This is constant unless responsive perPage option is set.\n     * @return {Number} The number of slides per page to display\n     */\n    currentPerPage: function currentPerPage() {\n      return !this.perPageCustom || this.$isServer ? this.perPage : this.breakpointSlidesPerPage;\n    },\n\n    /**\n     * The horizontal distance the inner wrapper is offset while navigating.\n     * @return {Number} Pixel value of offset to apply\n     */\n    currentOffset: function currentOffset() {\n      if (this.isCenterModeEnabled) {\n        return 0;\n      } else {\n        return (this.offset + this.dragOffset) * -1;\n      }\n    },\n    isHidden: function isHidden() {\n      return this.carouselWidth <= 0;\n    },\n\n    /**\n     * Maximum offset the carousel can slide\n     * Considering the spacePadding\n     * @return {Number}\n     */\n    maxOffset: function maxOffset() {\n      return Math.max(this.slideWidth * (this.slideCount - this.currentPerPage) - this.spacePadding * this.spacePaddingMaxOffsetFactor, 0);\n    },\n\n    /**\n     * Calculate the number of pages of slides\n     * @return {Number} Number of pages\n     */\n    pageCount: function pageCount() {\n      return this.scrollPerPage ? Math.ceil(this.slideCount / this.currentPerPage) : this.slideCount - this.currentPerPage + 1;\n    },\n\n    /**\n     * Calculate the width of each slide\n     * @return {Number} Slide width\n     */\n    slideWidth: function slideWidth() {\n      var width = this.carouselWidth - this.spacePadding * 2;\n      var perPage = this.currentPerPage;\n      return width / perPage;\n    },\n\n    /**\n     * @return {Boolean} Is navigation required?\n     */\n    isNavigationRequired: function isNavigationRequired() {\n      return this.slideCount <= this.currentPerPage ? false : true;\n    },\n\n    /**\n     * @return {Boolean} Center images when have less than min currentPerPage value\n     */\n    isCenterModeEnabled: function isCenterModeEnabled() {\n      return this.centerMode && !this.isNavigationRequired ? true : false;\n    },\n    transitionStyle: function transitionStyle() {\n      var speed = \"\".concat(this.speed / 1000, \"s\");\n      var transtion = \"\".concat(speed, \" \").concat(this.easing, \" transform\");\n\n      if (this.adjustableHeight) {\n        return \"\".concat(transtion, \", height \").concat(speed, \" \").concat(this.adjustableHeightEasing || this.easing);\n      }\n\n      return transtion;\n    },\n    padding: function padding() {\n      var padding = this.spacePadding;\n      return padding > 0 ? padding : false;\n    }\n  },\n  methods: {\n    /**\n     * @return {Number} The index of the next page\n     * */\n    getNextPage: function getNextPage() {\n      if (this.currentPage < this.pageCount - 1) {\n        return this.currentPage + 1;\n      }\n\n      return this.loop ? 0 : this.currentPage;\n    },\n\n    /**\n     * @return {Number} The index of the previous page\n     * */\n    getPreviousPage: function getPreviousPage() {\n      if (this.currentPage > 0) {\n        return this.currentPage - 1;\n      }\n\n      return this.loop ? this.pageCount - 1 : this.currentPage;\n    },\n\n    /**\n     * Increase/decrease the current page value\n     * @param  {String} direction (Optional) The direction to advance\n     */\n    advancePage: function advancePage(direction) {\n      if (direction && direction === \"backward\" && this.canAdvanceBackward) {\n        this.goToPage(this.getPreviousPage(), \"navigation\");\n      } else if ((!direction || direction && direction !== \"backward\") && this.canAdvanceForward) {\n        this.goToPage(this.getNextPage(), \"navigation\");\n      }\n    },\n    goToLastSlide: function goToLastSlide() {\n      var _this2 = this;\n\n      // following code is to disable animation\n      this.dragging = true; // clear dragging after refresh rate\n\n      setTimeout(function () {\n        _this2.dragging = false;\n      }, this.refreshRate);\n      this.$nextTick(function () {\n        _this2.goToPage(_this2.pageCount);\n      });\n    },\n\n    /**\n     * A mutation observer is used to detect changes to the containing node\n     * in order to keep the magnet container in sync with the height its reference node.\n     */\n    attachMutationObserver: function attachMutationObserver() {\n      var _this3 = this;\n\n      var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n\n      if (MutationObserver) {\n        var config = {\n          attributes: true,\n          data: true\n        };\n\n        if (this.adjustableHeight) {\n          config = _objectSpread({}, config, {\n            childList: true,\n            subtree: true,\n            characterData: true\n          });\n        }\n\n        this.mutationObserver = new MutationObserver(function () {\n          _this3.$nextTick(function () {\n            _this3.computeCarouselWidth();\n\n            _this3.computeCarouselHeight();\n          });\n        });\n\n        if (this.$parent.$el) {\n          var carouselInnerElements = this.$el.getElementsByClassName(\"VueCarousel-inner\");\n\n          for (var i = 0; i < carouselInnerElements.length; i++) {\n            this.mutationObserver.observe(carouselInnerElements[i], config);\n          }\n        }\n      }\n    },\n    handleNavigation: function handleNavigation(direction) {\n      this.advancePage(direction);\n    },\n\n    /**\n     * Stop listening to mutation changes\n     */\n    detachMutationObserver: function detachMutationObserver() {\n      if (this.mutationObserver) {\n        this.mutationObserver.disconnect();\n      }\n    },\n\n    /**\n     * Get the current browser viewport width\n     * @return {Number} Browser\"s width in pixels\n     */\n    getBrowserWidth: function getBrowserWidth() {\n      this.browserWidth = window.innerWidth;\n      return this.browserWidth;\n    },\n\n    /**\n     * Get the width of the carousel DOM element\n     * @return {Number} Width of the carousel in pixels\n     */\n    getCarouselWidth: function getCarouselWidth() {\n      var carouselInnerElements = this.$el.getElementsByClassName(\"VueCarousel-inner\");\n\n      for (var i = 0; i < carouselInnerElements.length; i++) {\n        if (carouselInnerElements[i].clientWidth > 0) {\n          this.carouselWidth = carouselInnerElements[i].clientWidth || 0;\n        }\n      }\n\n      return this.carouselWidth;\n    },\n\n    /**\n     * Get the maximum height of the carousel active slides\n     * @return {String} The carousel height\n     */\n    getCarouselHeight: function getCarouselHeight() {\n      var _this4 = this;\n\n      if (!this.adjustableHeight) {\n        return \"auto\";\n      }\n\n      var slideOffset = this.currentPerPage * (this.currentPage + 1) - 1;\n\n      var maxSlideHeight = _toConsumableArray(Array(this.currentPerPage)).map(function (_, idx) {\n        return _this4.getSlide(slideOffset + idx);\n      }).reduce(function (clientHeight, slide) {\n        return Math.max(clientHeight, slide && slide.$el.clientHeight || 0);\n      }, 0);\n\n      this.currentHeight = maxSlideHeight === 0 ? \"auto\" : \"\".concat(maxSlideHeight, \"px\");\n      return this.currentHeight;\n    },\n\n    /**\n     * Filter slot contents to slide instances and return length\n     * @return {Number} The number of slides\n     */\n    getSlideCount: function getSlideCount() {\n      var _this5 = this;\n\n      this.slideCount = this.$slots && this.$slots.default && this.$slots.default.filter(function (slot) {\n        return slot.tag && slot.tag.match(\"^vue-component-\\\\d+-\".concat(_this5.tagName, \"$\")) !== null;\n      }).length || 0;\n    },\n\n    /**\n     * Gets the slide at the specified index\n     * @return {Object} The slide at the specified index\n     */\n    getSlide: function getSlide(index) {\n      var _this6 = this;\n\n      var slides = this.$children.filter(function (child) {\n        return child.$vnode.tag.match(\"^vue-component-\\\\d+-\".concat(_this6.tagName, \"$\")) !== null;\n      });\n      return slides[index];\n    },\n\n    /**\n     * Set the current page to a specific value\n     * This function will only apply the change if the value is within the carousel bounds\n     * @param  {Number} page The value of the new page number\n     */\n    goToPage: function goToPage(page) {\n      if (page >= 0 && page <= this.pageCount) {\n        this.offset = this.scrollPerPage ? Math.min(this.slideWidth * this.currentPerPage * page, this.maxOffset) : Math.min(this.slideWidth * page, this.maxOffset); // restart autoplay if specified\n\n        if (this.autoplay && !this.autoplayHoverPause) {\n          this.restartAutoplay();\n        } // update the current page\n\n\n        this.currentPage = page;\n      }\n    },\n\n    /**\n     * Trigger actions when mouse is pressed\n     * @param  {Object} e The event object\n     */\n\n    /* istanbul ignore next */\n    onStart: function onStart(e) {\n      // alert(\"start\");\n      document.addEventListener(this.isTouch ? \"touchend\" : \"mouseup\", this.onEnd, true);\n      document.addEventListener(this.isTouch ? \"touchmove\" : \"mousemove\", this.onDrag, true);\n      this.startTime = e.timeStamp;\n      this.dragging = true;\n      this.dragStartX = this.isTouch ? e.touches[0].clientX : e.clientX;\n      this.dragStartY = this.isTouch ? e.touches[0].clientY : e.clientY;\n    },\n\n    /**\n     * Trigger actions when mouse is released\n     * @param  {Object} e The event object\n     */\n    onEnd: function onEnd(e) {\n      // restart autoplay if specified\n      if (this.autoplay && !this.autoplayHoverPause) {\n        this.restartAutoplay();\n      } // compute the momemtum speed\n\n\n      var eventPosX = this.isTouch ? e.changedTouches[0].clientX : e.clientX;\n      var deltaX = this.dragStartX - eventPosX;\n      this.dragMomentum = deltaX / (e.timeStamp - this.startTime); // take care of the minSwipteDistance prop, if not 0 and delta is bigger than delta\n\n      if (this.minSwipeDistance !== 0 && Math.abs(deltaX) >= this.minSwipeDistance) {\n        var width = this.scrollPerPage ? this.slideWidth * this.currentPerPage : this.slideWidth;\n        this.dragOffset = this.dragOffset + Math.sign(deltaX) * (width / 2);\n      }\n\n      this.offset += this.dragOffset;\n      this.dragOffset = 0;\n      this.dragging = false;\n      this.render(); // clear events listeners\n\n      document.removeEventListener(this.isTouch ? \"touchend\" : \"mouseup\", this.onEnd, true);\n      document.removeEventListener(this.isTouch ? \"touchmove\" : \"mousemove\", this.onDrag, true);\n    },\n\n    /**\n     * Trigger actions when mouse is pressed and then moved (mouse drag)\n     * @param  {Object} e The event object\n     */\n    onDrag: function onDrag(e) {\n      var eventPosX = this.isTouch ? e.touches[0].clientX : e.clientX;\n      var eventPosY = this.isTouch ? e.touches[0].clientY : e.clientY;\n      var newOffsetX = this.dragStartX - eventPosX;\n      var newOffsetY = this.dragStartY - eventPosY; // if it is a touch device, check if we are below the min swipe threshold\n      // (if user scroll the page on the component)\n\n      if (this.isTouch && Math.abs(newOffsetX) < Math.abs(newOffsetY)) {\n        return;\n      }\n\n      e.stopImmediatePropagation();\n      this.dragOffset = newOffsetX;\n      var nextOffset = this.offset + this.dragOffset;\n\n      if (nextOffset < 0) {\n        this.dragOffset = -Math.sqrt(-this.resistanceCoef * this.dragOffset);\n      } else if (nextOffset > this.maxOffset) {\n        this.dragOffset = Math.sqrt(this.resistanceCoef * this.dragOffset);\n      }\n    },\n    onResize: function onResize() {\n      var _this7 = this;\n\n      this.computeCarouselWidth();\n      this.computeCarouselHeight();\n      this.dragging = true; // force a dragging to disable animation\n\n      this.render(); // clear dragging after refresh rate\n\n      setTimeout(function () {\n        _this7.dragging = false;\n      }, this.refreshRate);\n    },\n    render: function render() {\n      // add extra slides depending on the momemtum speed\n      this.offset += Math.max(-this.currentPerPage + 1, Math.min(Math.round(this.dragMomentum), this.currentPerPage - 1)) * this.slideWidth; // & snap the new offset on a slide or page if scrollPerPage\n\n      var width = this.scrollPerPage ? this.slideWidth * this.currentPerPage : this.slideWidth; // lock offset to either the nearest page, or to the last slide\n\n      var lastFullPageOffset = width * Math.floor(this.slideCount / (this.currentPerPage - 1));\n      var remainderOffset = lastFullPageOffset + this.slideWidth * (this.slideCount % this.currentPerPage);\n\n      if (this.offset > (lastFullPageOffset + remainderOffset) / 2) {\n        this.offset = remainderOffset;\n      } else {\n        this.offset = width * Math.round(this.offset / width);\n      } // clamp the offset between 0 -> maxOffset\n\n\n      this.offset = Math.max(0, Math.min(this.offset, this.maxOffset)); // update the current page\n\n      this.currentPage = this.scrollPerPage ? Math.round(this.offset / this.slideWidth / this.currentPerPage) : Math.round(this.offset / this.slideWidth);\n    },\n\n    /**\n     * Re-compute the width of the carousel and its slides\n     */\n    computeCarouselWidth: function computeCarouselWidth() {\n      this.getSlideCount();\n      this.getBrowserWidth();\n      this.getCarouselWidth();\n      this.setCurrentPageInBounds();\n    },\n\n    /**\n     * Re-compute the height of the carousel and its slides\n     */\n    computeCarouselHeight: function computeCarouselHeight() {\n      this.getCarouselHeight();\n    },\n\n    /**\n     * When the current page exceeds the carousel bounds, reset it to the maximum allowed\n     */\n    setCurrentPageInBounds: function setCurrentPageInBounds() {\n      if (!this.canAdvanceForward && this.scrollPerPage) {\n        var setPage = this.pageCount - 1;\n        this.currentPage = setPage >= 0 ? setPage : 0;\n        this.offset = Math.max(0, Math.min(this.offset, this.maxOffset));\n      }\n    },\n    handleTransitionStart: function handleTransitionStart() {\n      this.$emit(\"transitionStart\");\n      this.$emit(\"transition-start\");\n    },\n    handleTransitionEnd: function handleTransitionEnd() {\n      this.$emit(\"transitionEnd\");\n      this.$emit(\"transition-end\");\n    }\n  },\n  mounted: function mounted() {\n    window.addEventListener(\"resize\", debounce(this.onResize, this.refreshRate)); // setup the start event only if touch device or mousedrag activated\n\n    if (this.isTouch && this.touchDrag || this.mouseDrag) {\n      this.$refs[\"VueCarousel-wrapper\"].addEventListener(this.isTouch ? \"touchstart\" : \"mousedown\", this.onStart);\n    }\n\n    this.attachMutationObserver();\n    this.computeCarouselWidth();\n    this.computeCarouselHeight();\n    this.transitionstart = getTransitionEnd();\n    this.$refs[\"VueCarousel-inner\"].addEventListener(this.transitionstart, this.handleTransitionStart);\n    this.transitionend = getTransitionEnd();\n    this.$refs[\"VueCarousel-inner\"].addEventListener(this.transitionend, this.handleTransitionEnd);\n    this.$emit(\"mounted\"); // when autoplay direction is backward start from the last slide\n\n    if (this.autoplayDirection === \"backward\") {\n      this.goToLastSlide();\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.detachMutationObserver();\n    window.removeEventListener(\"resize\", this.getBrowserWidth);\n    this.$refs[\"VueCarousel-inner\"].removeEventListener(this.transitionstart, this.handleTransitionStart);\n    this.$refs[\"VueCarousel-inner\"].removeEventListener(this.transitionend, this.handleTransitionEnd);\n    this.$refs[\"VueCarousel-wrapper\"].removeEventListener(this.isTouch ? \"touchstart\" : \"mousedown\", this.onStart);\n  }\n};",{"version":3,"sources":["Carousel.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <section\n    class=\"VueCarousel\"\n    v-bind:class=\"{ 'VueCarousel--reverse': paginationPosition === 'top' ,'VueCarousel--has-navigate' : navigationEnabled && isNavigationRequired }\"\n  >\n    <div\n      class=\"VueCarousel-wrapper\"\n      ref=\"VueCarousel-wrapper\"\n    >\n      <div\n        ref=\"VueCarousel-inner\"\n        :class=\"[\n          'VueCarousel-inner',\n          { 'VueCarousel-inner--center': isCenterModeEnabled }\n        ]\"\n        :style=\"{\n          'transform': `translate(${currentOffset}px, 0)`,\n          'transition': dragging ? 'none' : transitionStyle,\n          'ms-flex-preferred-size': `${slideWidth}px`,\n          'webkit-flex-basis': `${slideWidth}px`,\n          'flex-basis': `${slideWidth}px`,\n          'visibility': slideWidth ? 'visible' : 'hidden',\n          'height': `${currentHeight}`,\n          'padding-left': `${padding}px`,\n          'padding-right': `${padding}px`\n        }\"\n      >\n        <slot></slot>\n      </div>\n    </div>\n\n    <slot name=\"navigation\" v-if=\"navigationEnabled\">\n      <navigation\n        v-if=\"isNavigationRequired\"\n        :clickTargetSize=\"navigationClickTargetSize\"\n        :nextLabel=\"navigationNextLabel\"\n        :prevLabel=\"navigationPrevLabel\"\n        @navigationclick=\"handleNavigation\"\n      />\n    </slot>\n\n    <slot name=\"pagination\" v-if=\"paginationEnabled\">\n      <pagination @paginationclick=\"goToPage($event, 'pagination')\"/>\n    </slot>\n  </section>\n</template>\n<script>\nimport autoplay from \"./mixins/autoplay\";\nimport debounce from \"./utils/debounce\";\nimport Navigation from \"./Navigation.vue\";\nimport Pagination from \"./Pagination.vue\";\nimport Slide from \"./Slide.vue\";\n\nconst transitionStartNames = {\n  onwebkittransitionstart: \"webkitTransitionStart\",\n  onmoztransitionstart: \"transitionstart\",\n  onotransitionstart: \"oTransitionStart otransitionstart\",\n  ontransitionstart: \"transitionstart\"\n};\nconst transitionEndNames = {\n  onwebkittransitionend: \"webkitTransitionEnd\",\n  onmoztransitionend: \"transitionend\",\n  onotransitionend: \"oTransitionEnd otransitionend\",\n  ontransitionend: \"transitionend\"\n};\nconst getTransitionStart = () => {\n  for (let name in transitionStartNames) {\n    if (name in window) {\n      return transitionStartNames[name];\n    }\n  }\n};\nconst getTransitionEnd = () => {\n  for (let name in transitionEndNames) {\n    if (name in window) {\n      return transitionEndNames[name];\n    }\n  }\n};\n\nexport default {\n  name: \"carousel\",\n  beforeUpdate() {\n    this.computeCarouselWidth();\n  },\n  components: {\n    Navigation,\n    Pagination,\n    Slide\n  },\n  data() {\n    return {\n      browserWidth: null,\n      carouselWidth: 0,\n      currentPage: 0,\n      dragging: false,\n      dragMomentum: 0,\n      dragOffset: 0,\n      dragStartY: 0,\n      dragStartX: 0,\n      isTouch: typeof window !== \"undefined\" && \"ontouchstart\" in window,\n      offset: 0,\n      refreshRate: 16,\n      slideCount: 0,\n      transitionstart: \"transitionstart\",\n      transitionend: \"transitionend\",\n      currentHeight: \"auto\"\n    };\n  },\n  mixins: [autoplay],\n  // use `provide` to avoid `Slide` being nested with other components\n  provide() {\n    return {\n      carousel: this\n    };\n  },\n  props: {\n    /**\n     *  Adjust the height of the carousel for the current slide\n     */\n    adjustableHeight: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Slide transition easing for adjustableHeight\n     * Any valid CSS transition easing accepted\n     */\n    adjustableHeightEasing: {\n      type: String\n    },\n    /**\n     *  Center images when the size is less than the container width\n     */\n    centerMode: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Slide transition easing\n     * Any valid CSS transition easing accepted\n     */\n    easing: {\n      type: String,\n      default: \"ease\"\n    },\n    /**\n     * Flag to make the carousel loop around when it reaches the end\n     */\n    loop: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Minimum distance for the swipe to trigger\n     * a slide advance\n     */\n    minSwipeDistance: {\n      type: Number,\n      default: 8\n    },\n    /**\n     * Flag to toggle mouse dragging\n     */\n    mouseDrag: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * Flag to toggle touch dragging\n     */\n    touchDrag: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * Listen for an external navigation request using this prop.\n     */\n    navigateTo: {\n      type: [Number, Array],\n      default: 0\n    },\n    /**\n     * Amount of padding to apply around the label in pixels\n     */\n    navigationClickTargetSize: {\n      type: Number,\n      default: 8\n    },\n    /**\n     * Flag to render the navigation component\n     * (next/prev buttons)\n     */\n    navigationEnabled: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Text content of the navigation next button\n     */\n    navigationNextLabel: {\n      type: String,\n      default: \"&#9654\"\n    },\n    /**\n     * Text content of the navigation prev button\n     */\n    navigationPrevLabel: {\n      type: String,\n      default: \"&#9664\"\n    },\n    /**\n     * The fill color of the active pagination dot\n     * Any valid CSS color is accepted\n     */\n    paginationActiveColor: {\n      type: String,\n      default: \"#000000\"\n    },\n    /**\n     * The fill color of pagination dots\n     * Any valid CSS color is accepted\n     */\n    paginationColor: {\n      type: String,\n      default: \"#efefef\"\n    },\n    /**\n     * Flag to render pagination component\n     */\n    paginationEnabled: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     * The padding inside each pagination dot\n     * Pixel values are accepted\n     */\n    paginationPadding: {\n      type: Number,\n      default: 10\n    },\n    /**\n     * Configure the position for the pagination component.\n     * The possible values are: 'bottom', 'top', 'bottom-overlay' and 'top-overlay'\n     */\n    paginationPosition: {\n      type: String,\n      default: \"bottom\"\n    },\n    /**\n     * The size of each pagination dot\n     * Pixel values are accepted\n     */\n    paginationSize: {\n      type: Number,\n      default: 10\n    },\n    /**\n     * Maximum number of slides displayed on each page\n     */\n    perPage: {\n      type: Number,\n      default: 2\n    },\n    /**\n     * Configure the number of visible slides with a particular browser width.\n     * This will be an array of arrays, ex. [[320, 2], [1199, 4]]\n     * Formatted as [x, y] where x=browser width, and y=number of slides displayed.\n     * ex. [1199, 4] means if (window <= 1199) then show 4 slides per page\n     */\n    perPageCustom: {\n      type: Array\n    },\n    /**\n     * Resistance coefficient to dragging on the edge of the carousel\n     * This dictates the effect of the pull as you move towards the boundaries\n     */\n    resistanceCoef: {\n      type: Number,\n      default: 20\n    },\n    /**\n     * Scroll per page, not per item\n     */\n    scrollPerPage: {\n      type: Boolean,\n      default: true\n    },\n    /**\n     *  Space padding option adds left and right padding style (in pixels) onto VueCarousel-inner.\n     */\n    spacePadding: {\n      type: Number,\n      default: 0\n    },\n    /**\n     *  Specify by how much should the space padding value be multiplied of, to re-arange the final slide padding.\n     */\n    spacePaddingMaxOffsetFactor: {\n      type: Number,\n      default: 0\n    },\n    /**\n     * Slide transition speed\n     * Number of milliseconds accepted\n     */\n    speed: {\n      type: Number,\n      default: 500\n    },\n    /**\n     * Name (tag) of slide component\n     * Overwrite when extending slide component\n     */\n    tagName: {\n      type: String,\n      default: \"slide\"\n    },\n    /**\n     * Support for v-model functionality\n     */\n    value: {\n      type: Number\n    }\n  },\n  watch: {\n    value(val) {\n      if (val !== this.currentPage) {\n        this.goToPage(val);\n        this.render();\n      }\n    },\n    navigateTo: {\n      immediate: true,\n      handler(val) {\n        // checking if val is an array, for arrays typeof returns object\n        if (typeof val === \"object\") {\n          if (val[1] == false) {\n            // following code is to disable animation\n            this.dragging = true;\n\n            // clear dragging after refresh rate\n            setTimeout(() => {\n              this.dragging = false;\n            }, this.refreshRate);\n          }\n\n          this.$nextTick(() => {\n            this.goToPage(val[0]);\n          });\n        } else {\n          this.$nextTick(() => {\n            this.goToPage(val);\n          });\n        }\n      }\n    },\n    currentPage(val) {\n      this.$emit(\"pageChange\", val);\n      this.$emit(\"page-change\", val);\n      this.$emit(\"input\", val);\n    },\n    autoplay(val) {\n      if (val === false) {\n        this.pauseAutoplay();\n      } else {\n        this.restartAutoplay();\n      }\n    }\n  },\n  computed: {\n    /**\n     * Given a viewport width, find the number of slides to display\n     * @param  {Number} width Current viewport width in pixels\n     * @return {Number} Number of slides to display\n     */\n    breakpointSlidesPerPage() {\n      if (!this.perPageCustom) {\n        return this.perPage;\n      }\n\n      const breakpointArray = this.perPageCustom;\n      const width = this.browserWidth;\n\n      const breakpoints = breakpointArray.sort(\n        (a, b) => (a[0] > b[0] ? -1 : 1)\n      );\n\n      // Reduce the breakpoints to entries where the width is in range\n      // The breakpoint arrays are formatted as [widthToMatch, numberOfSlides]\n      const matches = breakpoints.filter(breakpoint => width >= breakpoint[0]);\n\n      // If there is a match, the result should return only\n      // the slide count from the first matching breakpoint\n      const match = matches[0] && matches[0][1];\n\n      return match || this.perPage;\n    },\n    /**\n     * @return {Boolean} Can the slider move forward?\n     */\n    canAdvanceForward() {\n      return this.loop || this.offset < this.maxOffset;\n    },\n    /**\n     * @return {Boolean} Can the slider move backward?\n     */\n    canAdvanceBackward() {\n      return this.loop || this.currentPage > 0;\n    },\n    /**\n     * Number of slides to display per page in the current context.\n     * This is constant unless responsive perPage option is set.\n     * @return {Number} The number of slides per page to display\n     */\n    currentPerPage() {\n      return !this.perPageCustom || this.$isServer\n        ? this.perPage\n        : this.breakpointSlidesPerPage;\n    },\n    /**\n     * The horizontal distance the inner wrapper is offset while navigating.\n     * @return {Number} Pixel value of offset to apply\n     */\n    currentOffset() {\n      if (this.isCenterModeEnabled) {\n        return 0;\n      } else {\n        return (this.offset + this.dragOffset) * -1;\n      }\n    },\n    isHidden() {\n      return this.carouselWidth <= 0;\n    },\n    /**\n     * Maximum offset the carousel can slide\n     * Considering the spacePadding\n     * @return {Number}\n     */\n    maxOffset() {\n      return Math.max(\n        this.slideWidth * (this.slideCount - this.currentPerPage) -\n          this.spacePadding * this.spacePaddingMaxOffsetFactor,\n        0\n      );\n    },\n    /**\n     * Calculate the number of pages of slides\n     * @return {Number} Number of pages\n     */\n    pageCount() {\n      return this.scrollPerPage\n        ? Math.ceil(this.slideCount / this.currentPerPage)\n        : this.slideCount - this.currentPerPage + 1;\n    },\n    /**\n     * Calculate the width of each slide\n     * @return {Number} Slide width\n     */\n    slideWidth() {\n      const width = this.carouselWidth - this.spacePadding * 2;\n      const perPage = this.currentPerPage;\n\n      return width / perPage;\n    },\n    /**\n     * @return {Boolean} Is navigation required?\n     */\n    isNavigationRequired() {\n      return this.slideCount <= this.currentPerPage ? false : true;\n    },\n    /**\n     * @return {Boolean} Center images when have less than min currentPerPage value\n     */\n    isCenterModeEnabled() {\n      return this.centerMode && !this.isNavigationRequired ? true : false;\n    },\n    transitionStyle() {\n      const speed = `${this.speed / 1000}s`;\n      const transtion = `${speed} ${this.easing} transform`;\n      if (this.adjustableHeight) {\n        return `${transtion}, height ${speed} ${this.adjustableHeightEasing ||\n          this.easing}`;\n      }\n\n      return transtion;\n    },\n    padding() {\n      const padding = this.spacePadding;\n      return padding > 0 ? padding : false;\n    }\n  },\n  methods: {\n    /**\n     * @return {Number} The index of the next page\n     * */\n    getNextPage() {\n      if (this.currentPage < this.pageCount - 1) {\n        return this.currentPage + 1;\n      }\n      return this.loop ? 0 : this.currentPage;\n    },\n    /**\n     * @return {Number} The index of the previous page\n     * */\n    getPreviousPage() {\n      if (this.currentPage > 0) {\n        return this.currentPage - 1;\n      }\n      return this.loop ? this.pageCount - 1 : this.currentPage;\n    },\n    /**\n     * Increase/decrease the current page value\n     * @param  {String} direction (Optional) The direction to advance\n     */\n    advancePage(direction) {\n      if (direction && direction === \"backward\" && this.canAdvanceBackward) {\n        this.goToPage(this.getPreviousPage(), \"navigation\");\n      } else if (\n        (!direction || (direction && direction !== \"backward\")) &&\n        this.canAdvanceForward\n      ) {\n        this.goToPage(this.getNextPage(), \"navigation\");\n      }\n    },\n    goToLastSlide() {\n      // following code is to disable animation\n      this.dragging = true;\n\n      // clear dragging after refresh rate\n      setTimeout(() => {\n        this.dragging = false;\n      }, this.refreshRate);\n\n      this.$nextTick(() => {\n        this.goToPage(this.pageCount);\n      });\n    },\n    /**\n     * A mutation observer is used to detect changes to the containing node\n     * in order to keep the magnet container in sync with the height its reference node.\n     */\n    attachMutationObserver() {\n      const MutationObserver =\n        window.MutationObserver ||\n        window.WebKitMutationObserver ||\n        window.MozMutationObserver;\n\n      if (MutationObserver) {\n        let config = {\n          attributes: true,\n          data: true\n        };\n        if (this.adjustableHeight) {\n          config = {\n            ...config,\n            childList: true,\n            subtree: true,\n            characterData: true\n          };\n        }\n        this.mutationObserver = new MutationObserver(() => {\n          this.$nextTick(() => {\n            this.computeCarouselWidth();\n            this.computeCarouselHeight();\n          });\n        });\n        if (this.$parent.$el) {\n          let carouselInnerElements = this.$el.getElementsByClassName(\n            \"VueCarousel-inner\"\n          );\n          for (let i = 0; i < carouselInnerElements.length; i++) {\n            this.mutationObserver.observe(carouselInnerElements[i], config);\n          }\n        }\n      }\n    },\n    handleNavigation(direction) {\n      this.advancePage(direction);\n    },\n    /**\n     * Stop listening to mutation changes\n     */\n    detachMutationObserver() {\n      if (this.mutationObserver) {\n        this.mutationObserver.disconnect();\n      }\n    },\n    /**\n     * Get the current browser viewport width\n     * @return {Number} Browser\"s width in pixels\n     */\n    getBrowserWidth() {\n      this.browserWidth = window.innerWidth;\n      return this.browserWidth;\n    },\n    /**\n     * Get the width of the carousel DOM element\n     * @return {Number} Width of the carousel in pixels\n     */\n    getCarouselWidth() {\n      let carouselInnerElements = this.$el.getElementsByClassName(\n        \"VueCarousel-inner\"\n      );\n      for (let i = 0; i < carouselInnerElements.length; i++) {\n        if (carouselInnerElements[i].clientWidth > 0) {\n          this.carouselWidth = carouselInnerElements[i].clientWidth || 0;\n        }\n      }\n      return this.carouselWidth;\n    },\n    /**\n     * Get the maximum height of the carousel active slides\n     * @return {String} The carousel height\n     */\n    getCarouselHeight() {\n      if (!this.adjustableHeight) {\n        return \"auto\";\n      }\n\n      const slideOffset = this.currentPerPage * (this.currentPage + 1) - 1;\n      const maxSlideHeight = [...Array(this.currentPerPage)]\n        .map((_, idx) => this.getSlide(slideOffset + idx))\n        .reduce(\n          (clientHeight, slide) =>\n            Math.max(clientHeight, (slide && slide.$el.clientHeight) || 0),\n          0\n        );\n\n      this.currentHeight =\n        maxSlideHeight === 0 ? \"auto\" : `${maxSlideHeight}px`;\n\n      return this.currentHeight;\n    },\n    /**\n     * Filter slot contents to slide instances and return length\n     * @return {Number} The number of slides\n     */\n    getSlideCount() {\n      this.slideCount =\n        (this.$slots &&\n          this.$slots.default &&\n          this.$slots.default.filter(\n            slot =>\n              slot.tag &&\n              slot.tag.match(`^vue-component-\\\\d+-${this.tagName}$`) !== null\n          ).length) ||\n        0;\n    },\n    /**\n     * Gets the slide at the specified index\n     * @return {Object} The slide at the specified index\n     */\n    getSlide(index) {\n      const slides = this.$children.filter(\n        child =>\n          child.$vnode.tag.match(`^vue-component-\\\\d+-${this.tagName}$`) !==\n          null\n      );\n      return slides[index];\n    },\n    /**\n     * Set the current page to a specific value\n     * This function will only apply the change if the value is within the carousel bounds\n     * @param  {Number} page The value of the new page number\n     */\n    goToPage(page) {\n      if (page >= 0 && page <= this.pageCount) {\n        this.offset = this.scrollPerPage\n          ? Math.min(\n              this.slideWidth * this.currentPerPage * page,\n              this.maxOffset\n            )\n          : Math.min(this.slideWidth * page, this.maxOffset);\n\n        // restart autoplay if specified\n        if (this.autoplay && !this.autoplayHoverPause) {\n          this.restartAutoplay();\n        }\n\n        // update the current page\n        this.currentPage = page;\n      }\n    },\n    /**\n     * Trigger actions when mouse is pressed\n     * @param  {Object} e The event object\n     */\n    /* istanbul ignore next */\n    onStart(e) {\n      // alert(\"start\");\n      document.addEventListener(\n        this.isTouch ? \"touchend\" : \"mouseup\",\n        this.onEnd,\n        true\n      );\n\n      document.addEventListener(\n        this.isTouch ? \"touchmove\" : \"mousemove\",\n        this.onDrag,\n        true\n      );\n\n      this.startTime = e.timeStamp;\n      this.dragging = true;\n      this.dragStartX = this.isTouch ? e.touches[0].clientX : e.clientX;\n      this.dragStartY = this.isTouch ? e.touches[0].clientY : e.clientY;\n    },\n    /**\n     * Trigger actions when mouse is released\n     * @param  {Object} e The event object\n     */\n\n    onEnd(e) {\n      // restart autoplay if specified\n      if (this.autoplay && !this.autoplayHoverPause) {\n        this.restartAutoplay();\n      }\n\n      // compute the momemtum speed\n      const eventPosX = this.isTouch ? e.changedTouches[0].clientX : e.clientX;\n      const deltaX = this.dragStartX - eventPosX;\n      this.dragMomentum = deltaX / (e.timeStamp - this.startTime);\n\n      // take care of the minSwipteDistance prop, if not 0 and delta is bigger than delta\n      if (\n        this.minSwipeDistance !== 0 &&\n        Math.abs(deltaX) >= this.minSwipeDistance\n      ) {\n        const width = this.scrollPerPage\n          ? this.slideWidth * this.currentPerPage\n          : this.slideWidth;\n        this.dragOffset = this.dragOffset + Math.sign(deltaX) * (width / 2);\n      }\n\n      this.offset += this.dragOffset;\n      this.dragOffset = 0;\n      this.dragging = false;\n\n      this.render();\n\n      // clear events listeners\n      document.removeEventListener(\n        this.isTouch ? \"touchend\" : \"mouseup\",\n        this.onEnd,\n        true\n      );\n      document.removeEventListener(\n        this.isTouch ? \"touchmove\" : \"mousemove\",\n        this.onDrag,\n        true\n      );\n    },\n    /**\n     * Trigger actions when mouse is pressed and then moved (mouse drag)\n     * @param  {Object} e The event object\n     */\n    onDrag(e) {\n      const eventPosX = this.isTouch ? e.touches[0].clientX : e.clientX;\n      const eventPosY = this.isTouch ? e.touches[0].clientY : e.clientY;\n      const newOffsetX = this.dragStartX - eventPosX;\n      const newOffsetY = this.dragStartY - eventPosY;\n\n      // if it is a touch device, check if we are below the min swipe threshold\n      // (if user scroll the page on the component)\n      if (this.isTouch && Math.abs(newOffsetX) < Math.abs(newOffsetY)) {\n        return;\n      }\n\n      e.stopImmediatePropagation();\n\n      this.dragOffset = newOffsetX;\n      const nextOffset = this.offset + this.dragOffset;\n      if (nextOffset < 0) {\n        this.dragOffset = -Math.sqrt(-this.resistanceCoef * this.dragOffset);\n      } else if (nextOffset > this.maxOffset) {\n        this.dragOffset = Math.sqrt(this.resistanceCoef * this.dragOffset);\n      }\n    },\n    onResize() {\n      this.computeCarouselWidth();\n      this.computeCarouselHeight();\n\n      this.dragging = true; // force a dragging to disable animation\n      this.render();\n      // clear dragging after refresh rate\n      setTimeout(() => {\n        this.dragging = false;\n      }, this.refreshRate);\n    },\n    render() {\n      // add extra slides depending on the momemtum speed\n      this.offset +=\n        Math.max(\n          -this.currentPerPage + 1,\n          Math.min(Math.round(this.dragMomentum), this.currentPerPage - 1)\n        ) * this.slideWidth;\n\n      // & snap the new offset on a slide or page if scrollPerPage\n      const width = this.scrollPerPage\n        ? this.slideWidth * this.currentPerPage\n        : this.slideWidth;\n\n      // lock offset to either the nearest page, or to the last slide\n      const lastFullPageOffset =\n        width * Math.floor(this.slideCount / (this.currentPerPage - 1));\n      const remainderOffset =\n        lastFullPageOffset +\n        this.slideWidth * (this.slideCount % this.currentPerPage);\n      if (this.offset > (lastFullPageOffset + remainderOffset) / 2) {\n        this.offset = remainderOffset;\n      } else {\n        this.offset = width * Math.round(this.offset / width);\n      }\n\n      // clamp the offset between 0 -> maxOffset\n      this.offset = Math.max(0, Math.min(this.offset, this.maxOffset));\n\n      // update the current page\n      this.currentPage = this.scrollPerPage\n        ? Math.round(this.offset / this.slideWidth / this.currentPerPage)\n        : Math.round(this.offset / this.slideWidth);\n    },\n    /**\n     * Re-compute the width of the carousel and its slides\n     */\n    computeCarouselWidth() {\n      this.getSlideCount();\n      this.getBrowserWidth();\n      this.getCarouselWidth();\n      this.setCurrentPageInBounds();\n    },\n    /**\n     * Re-compute the height of the carousel and its slides\n     */\n    computeCarouselHeight() {\n      this.getCarouselHeight();\n    },\n    /**\n     * When the current page exceeds the carousel bounds, reset it to the maximum allowed\n     */\n    setCurrentPageInBounds() {\n      if (!this.canAdvanceForward && this.scrollPerPage) {\n        const setPage = this.pageCount - 1;\n        this.currentPage = setPage >= 0 ? setPage : 0;\n        this.offset = Math.max(0, Math.min(this.offset, this.maxOffset));\n      }\n    },\n    handleTransitionStart() {\n      this.$emit(\"transitionStart\");\n      this.$emit(\"transition-start\");\n    },\n    handleTransitionEnd() {\n      this.$emit(\"transitionEnd\");\n      this.$emit(\"transition-end\");\n    }\n  },\n  mounted() {\n    window.addEventListener(\n      \"resize\",\n      debounce(this.onResize, this.refreshRate)\n    );\n\n    // setup the start event only if touch device or mousedrag activated\n    if ((this.isTouch && this.touchDrag) || this.mouseDrag) {\n      this.$refs[\"VueCarousel-wrapper\"].addEventListener(\n        this.isTouch ? \"touchstart\" : \"mousedown\",\n        this.onStart\n      );\n    }\n\n    this.attachMutationObserver();\n    this.computeCarouselWidth();\n    this.computeCarouselHeight();\n\n    this.transitionstart = getTransitionEnd();\n    this.$refs[\"VueCarousel-inner\"].addEventListener(\n      this.transitionstart,\n      this.handleTransitionStart\n    );\n    this.transitionend = getTransitionEnd();\n    this.$refs[\"VueCarousel-inner\"].addEventListener(\n      this.transitionend,\n      this.handleTransitionEnd\n    );\n\n    this.$emit(\"mounted\");\n\n    // when autoplay direction is backward start from the last slide\n    if (this.autoplayDirection === \"backward\") {\n      this.goToLastSlide();\n    }\n  },\n  beforeDestroy() {\n    this.detachMutationObserver();\n    window.removeEventListener(\"resize\", this.getBrowserWidth);\n    this.$refs[\"VueCarousel-inner\"].removeEventListener(\n      this.transitionstart,\n      this.handleTransitionStart\n    );\n    this.$refs[\"VueCarousel-inner\"].removeEventListener(\n      this.transitionend,\n      this.handleTransitionEnd\n    );\n\n    this.$refs[\"VueCarousel-wrapper\"].removeEventListener(\n      this.isTouch ? \"touchstart\" : \"mousedown\",\n      this.onStart\n    );\n  }\n};\n</script>\n<style lang=\"scss\" scoped>\n  .VueCarousel {\n    display: flex;\n    flex-direction: column;\n    position: relative;\n    &.VueCarousel--has-navigate{\n      padding: 0 32px;\n    }\n  }\n\n  .VueCarousel--reverse {\n    flex-direction: column-reverse;\n  }\n\n  .VueCarousel-wrapper {\n    width: 100%;\n    position: relative;\n    overflow: hidden;\n  }\n\n  .VueCarousel-inner {\n    display: flex;\n    flex-direction: row;\n    backface-visibility: hidden;\n  }\n\n  .VueCarousel-inner--center {\n    justify-content: center;\n  }\n</style>\n"],"sourceRoot":"src/components/v-carousel"}]}